////////////////////////////////////////////////////////////////////////////
//
// nrLibrary.inl
//
// A class for librarying.
//
// Nate Robins, March 2002.
//
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////

#include "nrLibrary.h"


////////////////////////////////////////////////////////////////////////////
// Public
////////////////////////////////////////////////////////////////////////////

template <class T> inline nrLibrary<T>::nrLibrary( void )
{
}

////////////////////////////////////////////////////////////////////////////

template <class T> inline nrLibrary<T>::~nrLibrary( void )
{
	for ( int i = 0; i < m_Keys.Length(); i++ )
	{
		delete [] m_Keys[ i ];
	}
}

////////////////////////////////////////////////////////////////////////////

template <class T> inline void nrLibrary<T>::Add( const char* key, T* item )
{
    assert( item );
	
    if ( Find( key ) == 0 )
    {
		char* k = new char[ strlen( key ) + 1 ];
		strcpy( k, key );
		m_Keys.Add( k );
        m_Items.Add( item );
    }
}

////////////////////////////////////////////////////////////////////////////

template <class T> inline T* nrLibrary<T>::Find( const char* key ) const
{
	for ( int i = 0; i < m_Keys.Length(); i++ )
	{
		if ( key && m_Keys[ i ] && ( strcmp( key, m_Keys[ i ] ) == 0 ) )
		{
			return m_Items[ i ];
		}
	}
    
    return 0;
}

////////////////////////////////////////////////////////////////////////////
